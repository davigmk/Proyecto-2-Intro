"""
Proyecto 2 - Escapa del laberinto / Cazador.
Grupo: David & Mario.
Curso: Introducción a la Programación - Tec.
"""

import tkinter as tk
from tkinter import messagebox
import random
import time
import os

# -------------------------------------------------#
#                      Sonidos                     #
# -------------------------------------------------#

try:
    import winsound

    #E: freq (int), dur (int milisegundos).
    #S: X.
    #R: freq y dur deben ser positivos.
    # Reproduce un beep con winsound en Windows.

    def _beep(freq, dur):
        winsound.Beep(freq, dur)

except Exception:
    #E: freq (int), dur (int milisegundos)
    #S: X
    #R: Ninguna, función silenciosa en sistemas sin winsound
    # Dummy de beep para sistemas sin winsound

    def _beep(freq, dur):
        pass

#E: Evento (str).
#S: X.
#R: evento debe ser una clave conocida o se ignora.
# Reproduce un sonido diferente según el tipo de evento de juego.

def reproducir_sonido(evento):
    if evento == "trampa_colocada":
        _beep(900, 120)
    elif evento == "enemigo_en_trampa":
        _beep(500, 180)
    elif evento == "escapa_gana":
        _beep(1200, 250)
        _beep(1400, 250)
    elif evento == "escapa_pierde":
        _beep(400, 400)
    elif evento == "cazador_atrapa":
        _beep(1100, 180)
    elif evento == "enemigo_escapa":
        _beep(600, 220)
    elif evento == "enemigo_respawn":
        _beep(800, 100)

# ===========================================================#
#                 Constantes, tipos y casillas               #
# ===========================================================#

# Tipos de terreno
CAMINO = 0
LIANA = 1
TUNEL = 2
MURO = 3

# Colores para dibujar en el canvass
COLORES_TERRRENO = {
    CAMINO: "#d0d0d0",   # gris claro
    LIANA: "#4fbf4a",    # verde liana
    TUNEL: "#4e7dd9",    # azul túnel
    MURO: "#222222",     # negro/gris oscuro
}

TAM_CELDA = 26
FILAS_MAPA = 15
COLS_MAPA = 20

# Archivos de puntajes
SCORES_ESCAPA_FILE = "scores_escapa.txt"
SCORES_CAZADOR_FILE = "scores_cazador.txt"

#E: tipo (int),
#S: X.
#R: tipo debe ser uno de CAMNO, LIANA, TUNEL o MURO.
# Clase basee de casilla en el mapa.

class Casilla:
    def __init__(self, tipo):
        self.tipo = tipo

    #E: X
    #S: boolean
    #R: X
    # Indica si el jugador puede pasar por esta casilla.
    def permite_jugador(self):
        return False

    #E: X
    #S: boolen
    #R: X
    # Indica si un enemigo puede pasar por esta casilla.
    def permite_enemigo(self):
        return False

#E: X
#S: X
#R: X
# Casilla de tipo CAMINO, la más basica

class Camino(Casilla):

    def __init__(self):
        super().__init__(CAMINO)

    #E: X
    #S: bool
    #R: X
    # El jugador si puede pasar por el camino.
    def permite_jugador(self):
        return True

    #E: X
    #S: bool
    #R: X
    # El enemigo también puede pasar por el camino.
    def permite_enemigo(self):
        return True

#E: X
#S: X
#R: X
# Casilla de tipo LIAMA, solo la usan los enemigos (cazadores).
class Liana(Casilla):
    def __init__(self):
        super().__init__(LIANA)

    #E: X
    #S: bool
    #R: X
    # El jugador no puede pasar por lianas (se controla en Jugador según modo).
    def permite_jugador(self):
        return False

    #E: X
    #S: bool
    #R: X
    # El enemigo sí puede usar lianas para moverse.
    def permite_enemigo(self):
        return True

#E: X
#S: X
#R: X
# Casilla de tipo TUNEL, exclusiva del jugador escapista.
class Tunel(Casilla):
    def __init__(self):
        super().__init__(TUNEL)

    #E: X
    #S: bool
    #R: X
    # El jugador sI puede usar túneles (se filtra en Jugador según modo).
    def permite_jugador(self):
        return True

    #E: X
    #S: bool
    #R: X
    # El enemigo no puede pasar por túneles.
    def permite_enemigo(self):
        return False

#E: X.
#S: X.
#R: X.
# Casilla de tipo MURO, nadie puede pasar.
class Muro(Casilla):
    def __init__(self):
        super().__init__(MURO)

    #E: X.
    #S: bool.
    #R: X..
    # El jugador no puede pasar muros.
    def permite_jugador(self):
        return False

    #E: X.
    #S: bool.
    #R: X.
    # El enemigo tampoco puede pasar muros.
    def permite_enemigo(self):
        return False

# ============================================================
#            Laberinto y generación aleatoria                #
# ============================================================

#E: filas (int), cols (int)
#S: X
#R: filas y cols > 0
# Genera el mapa y asegura un camino valido de inicio a salida

class Laberinto:
    def __init__(self, filas, cols):
        self.filas = filas
        self.cols = cols
        self.inicio = (0, 0)
        self.salida = (filas - 1, cols - 1)
        self.mapa = [[Camino() for _ in range(cols)] for _ in range(filas)]
        self.generar_mapa()

    #E: X
    #S: X
    #R: X
    # Genera un mapa con un camino fijo y el resto aleatorio.

    def generar_mapa(self):
        grid = [[MURO for _ in range(self.cols)] for _ in range(self.filas)]
        # camino base zig-zag fijo
        r, c = self.inicio
        grid[r][c] = CAMINO
        while r < self.salida[0]:
            r += 1
            grid[r][c] = CAMINO
        while c < self.salida[1]:
            c += 1
            grid[r][c] = CAMINO

        # rellena el resto
        for i in range(self.filas):
            for j in range(self.cols):
                if grid[i][j] == CAMINO:
                    continue
                tipo_random = random.choices(
                    population=[CAMINO, LIANA, TUNEL, MURO],
                    weights=[0.5, 0.15, 0.15, 0.2],
                )[0]
                grid[i][j] = tipo_random

        nuevo_mapa = []
        for i in range(self.filas):
            fila_clases = []
            for j in range(self.cols):
                tipo = grid[i][j]
                if tipo == CAMINO:
                    fila_clases.append(Camino())
                elif tipo == LIANA:
                    fila_clases.append(Liana())
                elif tipo == TUNEL:
                    fila_clases.append(Tunel())
                else:
                    fila_clases.append(Muro())
            nuevo_mapa.append(fila_clases)
        self.mapa = nuevo_mapa

    #E: fila (int), col (int)
    #S: bool
    #R: X
    # Indica si una posición está dentro del tamaño del laberinto.
    def dentro_rango(self, fila, col):
        return 0 <= fila < self.filas and 0 <= col < self.cols

    #E: fila (int), col (int)
    #S: Casilla o None
    #R: X
    # Devuelve la casilla de una posición o none si está fuera del mapa
    def casilla(self, fila, col):
        if not self.dentro_rango(fila, col):
            return None
        return self.mapa[fila][col]

    #E: fila (int), col (int)
    #S: bool
    #R: X
    # Indica si el jugador puede estar en esa posición
    def permite_jugador(self, fila, col):
        c = self.casilla(fila, col)
        if c is None:
            return False
        return c.permite_jugador()

    #E: fila (int), col (int)
    #S: bool
    #R: X
    # Indica si un enemigo puede estar en esa posicion
    def permite_enemigo(self, fila, col):
        c = self.casilla(fila, col)
        if c is None:
            return False
        return c.permite_enemigo()

# ============================================================#
#                  Jugador, Enemigo y trampas                 #
# ============================================================#

#E: fila (int), col (int)
#S: X
#R: X
# Clase base con posición (fila, col) en el mapa.

class PersonajeBase:
    def __init__(self, fila, col):
        self.fila = fila
        self.col = col

    #E: X
    #S: tupla (fila, col)
    #R: X
    # Devuelve la posición actual del personaje.
    
    def posicion(self):
        return self.fila, self.col


#E: fila (int), col (int), modo (str)
#S: X
#R: modo debe ser "escapa" o "cazador"
# Representa al jugador (escapista o cazador).

class Jugador(PersonajeBase):
    def __init__(self, fila, col, modo):
        super().__init__(fila, col)
        self.modo = modo
        self.energia_max = 100
        self.energia = self.energia_max
        self.vivo = True
        self.trampas = []          # lista de (fila, col, timestamp)
        self.ultimo_trampa = 0.0   # tiempo del último intento de trampa

    #E: lab (Laberinto), nf (int), nc (int)
    #S: bool
    #R: nf y nc dentro del rango del laberinto
    # Indica si el jugador puede moverse a la casilla dada según su modo.
    def puede_mover(self, lab, nf, nc):
        cas = lab.casilla(nf, nc)
        if cas is None:
            return False
        # MURO: nadie
        if cas.tipo == MURO:
            return False
        # CAMINO: siempre
        if cas.tipo == CAMINO:
            return True
        # LIANA: solo cazador
        if cas.tipo == LIANA:
            return self.modo == "cazador"
        # TUNEL: solo escapista
        if cas.tipo == TUNEL:
            return self.modo == "escapa"
        return False

    #E: lab (Laberinto), df (int), dc (int), corriendo (bool)
    #S: bool
    #R: df y dc deben ser -1,0 o 1
    # Mueve al jugador una casilla si es posible, usando energía si va corriendo.
    def mover(self, lab, df, dc, corriendo):
        if not self.vivo:
            return False
        nf = self.fila + df
        nc = self.col + dc
        if not lab.dentro_rango(nf, nc):
            return False
        if not self.puede_mover(lab, nf, nc):
            return False

        self.fila = nf
        self.col = nc
        return True

    #E: X
    #S: bool
    #R: X
    # Indica si el jugador puede colocar una trampa en ese momento.
    def puede_colocar_trampa(self):
        ahora = time.time()
        if len(self.trampas) >= 3:
            return False
        if ahora - self.ultimo_trampa < 5.0:
            return False
        return True

    #E: X
    #S: bool
    #R: X
    # Coloca una trampa en la posición actual si es posible.
    def colocar_trampa(self):
        if self.puede_colocar_trampa():
            self.trampas.append((self.fila, self.col, time.time()))
            self.ultimo_trampa = time.time()
            return True
        return False

    #E: X
    #S: X
    #R: X
    # Limpia trampas viejas (no se usa tiempo de expiración en este diseño).
    def limpiar_trampas_viejas(self):
        nuevas = []
        for (f, c, t0) in self.trampas:
            nuevas.append((f, c, t0))
        self.trampas = nuevas

#E: fila (int), col (int)
#S: X
#R: X
# Representa a un enemigo (cazador o escapista según el modo).
class Enemigo(PersonajeBase):
    def __init__(self, fila, col):
        super().__init__(fila, col)
        self.vivo = True
        self.muerto_timestamp = 0.0

    #E: lab (Laberinto), nf (int), nc (int)
    #S: bool
    #R: nf y nc dentro de rango
    # Indica si el enemigo puede estar en esa casilla.
    def puede_mover(self, lab, nf, nc):
        return lab.permite_enemigo(nf, nc)

    #E: lab (Laberinto), objetivo_f (int), objetivo_c (int)
    #S: X
    #R: X
    # Mueve al enemigo aproximándose al objetivo usando distancia Manhattan.
    def mover_hacia(self, lab, objetivo_f, objetivo_c):
        if not self.vivo:
            return
        vecinos = self._vecinos_validos(lab)
        if not vecinos:
            return
        mejor = None
        mejor_dist = None
        for nf, nc in vecinos:
            dist = abs(nf - objetivo_f) + abs(nc - objetivo_c)
            if mejor is None or dist < mejor_dist:
                mejor = (nf, nc)
                mejor_dist = dist
        if mejor is not None:
            self.fila, self.col = mejor

    #E: lab (Laberinto), jugador_f (int), jugador_c (int)
    #S: X
    #R: X
    # Mueve al enemigo intentando alejarse del jugador.
    def mover_alejandose(self, lab, jugador_f, jugador_c):
        if not self.vivo:
            return
        vecinos = self._vecinos_validos(lab)
        if not vecinos:
            return
        mejor = (self.fila, self.col)
        mejor_dist = abs(self.fila - jugador_f) + abs(self.col - jugador_c)
        for nf, nc in vecinos:
            dist = abs(nf - jugador_f) + abs(nc - jugador_c)
            if dist > mejor_dist:
                mejor = (nf, nc)
                mejor_dist = dist
        self.fila, self.col = mejor

    #E: lab (Laberinto)
    #S: lista de tuplas (fila,col)
    #R: X
    # Devuelve lista de casillas vecinas válidas a las que puede moverse.

    def _vecinos_validos(self, lab):
        dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        res = []
        for df, dc in dirs:
            nf = self.fila + df
            nc = self.col + dc
            if lab.dentro_rango(nf, nc) and self.puede_mover(lab, nf, nc):
                res.append((nf, nc))
        return res

"""
Proyecto 2 - Escapa del laberinto / Cazador.
Grupo: David & Mario.
Curso: Introducción a la Programación - Tec.
"""

import tkinter as tk
from tkinter import messagebox
import random
import time
import os

# -------------------------------------------------#
#                      Sonidos                     #
# -------------------------------------------------#

try:
    import winsound

    #E: freq (int), dur (int milisegundos).
    #S: X.
    #R: freq y dur deben ser positivos.
    # Reproduce un beep con winsound en Windows.

    def _beep(freq, dur):
        winsound.Beep(freq, dur)

except Exception:
    #E: freq (int), dur (int milisegundos)
    #S: X
    #R: Ninguna, función silenciosa en sistemas sin winsound
    # Dummy de beep para sistemas sin winsound

    def _beep(freq, dur):
        pass

#E: Evento (str).
#S: X.
#R: evento debe ser una clave conocida o se ignora.
# Reproduce un sonido diferente según el tipo de evento de juego.

def reproducir_sonido(evento):
    if evento == "trampa_colocada":
        _beep(900, 120)
    elif evento == "enemigo_en_trampa":
        _beep(500, 180)
    elif evento == "escapa_gana":
        _beep(1200, 250)
        _beep(1400, 250)
    elif evento == "escapa_pierde":
        _beep(400, 400)
    elif evento == "cazador_atrapa":
        _beep(1100, 180)
    elif evento == "enemigo_escapa":
        _beep(600, 220)
    elif evento == "enemigo_respawn":
        _beep(800, 100)

# ===========================================================#
#                 Constantes, tipos y casillas               #
# ===========================================================#

# Tipos de terreno
CAMINO = 0
LIANA = 1
TUNEL = 2
MURO = 3

# Colores para dibujar en el canvass
COLORES_TERRRENO = {
    CAMINO: "#d0d0d0",   # gris claro
    LIANA: "#4fbf4a",    # verde liana
    TUNEL: "#4e7dd9",    # azul túnel
    MURO: "#222222",     # negro/gris oscuro
}

TAM_CELDA = 26
FILAS_MAPA = 15
COLS_MAPA = 20

# Archivos de puntajes
SCORES_ESCAPA_FILE = "scores_escapa.txt"
SCORES_CAZADOR_FILE = "scores_cazador.txt"

#E: tipo (int),
#S: X.
#R: tipo debe ser uno de CAMNO, LIANA, TUNEL o MURO.
# Clase basee de casilla en el mapa.

class Casilla:
    def __init__(self, tipo):
        self.tipo = tipo

    #E: X
    #S: boolean
    #R: X
    # Indica si el jugador puede pasar por esta casilla.
    def permite_jugador(self):
        return False

    #E: X
    #S: boolen
    #R: X
    # Indica si un enemigo puede pasar por esta casilla.
    def permite_enemigo(self):
        return False

#E: X
#S: X
#R: X
# Casilla de tipo CAMINO, la más basica

class Camino(Casilla):

    def __init__(self):
        super().__init__(CAMINO)

    #E: X
    #S: bool
    #R: X
    # El jugador si puede pasar por el camino.
    def permite_jugador(self):
        return True

    #E: X
    #S: bool
    #R: X
    # El enemigo también puede pasar por el camino.
    def permite_enemigo(self):
        return True

#E: X
#S: X
#R: X
# Casilla de tipo LIAMA, solo la usan los enemigos (cazadores).
class Liana(Casilla):
    def __init__(self):
        super().__init__(LIANA)

    #E: X
    #S: bool
    #R: X
    # El jugador no puede pasar por lianas (se controla en Jugador según modo).
    def permite_jugador(self):
        return False

    #E: X
    #S: bool
    #R: X
    # El enemigo sí puede usar lianas para moverse.
    def permite_enemigo(self):
        return True

#E: X
#S: X
#R: X
# Casilla de tipo TUNEL, exclusiva del jugador escapista.
class Tunel(Casilla):
    def __init__(self):
        super().__init__(TUNEL)

    #E: X
    #S: bool
    #R: X
    # El jugador sI puede usar túneles (se filtra en Jugador según modo).
    def permite_jugador(self):
        return True

    #E: X
    #S: bool
    #R: X
    # El enemigo no puede pasar por túneles.
    def permite_enemigo(self):
        return False

#E: X.
#S: X.
#R: X.
# Casilla de tipo MURO, nadie puede pasar.
class Muro(Casilla):
    def __init__(self):
        super().__init__(MURO)

    #E: X.
    #S: bool.
    #R: X..
    # El jugador no puede pasar muros.
    def permite_jugador(self):
        return False

    #E: X.
    #S: bool.
    #R: X.
    # El enemigo tampoco puede pasar muros.
    def permite_enemigo(self):
        return False

# ============================================================
#            Laberinto y generación aleatoria                #
# ============================================================

#E: filas (int), cols (int)
#S: X
#R: filas y cols > 0
# Genera el mapa y asegura un camino valido de inicio a salida

class Laberinto:
    def __init__(self, filas, cols):
        self.filas = filas
        self.cols = cols
        self.inicio = (0, 0)
        self.salida = (filas - 1, cols - 1)
        self.mapa = [[Camino() for _ in range(cols)] for _ in range(filas)]
        self.generar_mapa()

    #E: X
    #S: X
    #R: X
    # Genera un mapa con un camino fijo y el resto aleatorio.

    def generar_mapa(self):
        grid = [[MURO for _ in range(self.cols)] for _ in range(self.filas)]
        # camino base zig-zag fijo
        r, c = self.inicio
        grid[r][c] = CAMINO
        while r < self.salida[0]:
            r += 1
            grid[r][c] = CAMINO
        while c < self.salida[1]:
            c += 1
            grid[r][c] = CAMINO

        # rellena el resto
        for i in range(self.filas):
            for j in range(self.cols):
                if grid[i][j] == CAMINO:
                    continue
                tipo_random = random.choices(
                    population=[CAMINO, LIANA, TUNEL, MURO],
                    weights=[0.5, 0.15, 0.15, 0.2],
                )[0]
                grid[i][j] = tipo_random

        nuevo_mapa = []
        for i in range(self.filas):
            fila_clases = []
            for j in range(self.cols):
                tipo = grid[i][j]
                if tipo == CAMINO:
                    fila_clases.append(Camino())
                elif tipo == LIANA:
                    fila_clases.append(Liana())
                elif tipo == TUNEL:
                    fila_clases.append(Tunel())
                else:
                    fila_clases.append(Muro())
            nuevo_mapa.append(fila_clases)
        self.mapa = nuevo_mapa

    #E: fila (int), col (int)
    #S: bool
    #R: X
    # Indica si una posición está dentro del tamaño del laberinto.
    def dentro_rango(self, fila, col):
        return 0 <= fila < self.filas and 0 <= col < self.cols

    #E: fila (int), col (int)
    #S: Casilla o None
    #R: X
    # Devuelve la casilla de una posición o none si está fuera del mapa
    def casilla(self, fila, col):
        if not self.dentro_rango(fila, col):
            return None
        return self.mapa[fila][col]

    #E: fila (int), col (int)
    #S: bool
    #R: X
    # Indica si el jugador puede estar en esa posición
    def permite_jugador(self, fila, col):
        c = self.casilla(fila, col)
        if c is None:
            return False
        return c.permite_jugador()

    #E: fila (int), col (int)
    #S: bool
    #R: X
    # Indica si un enemigo puede estar en esa posicion
    def permite_enemigo(self, fila, col):
        c = self.casilla(fila, col)
        if c is None:
            return False
        return c.permite_enemigo()

# ============================================================#
#                  Jugador, Enemigo y trampas                 #
# ============================================================#

#E: fila (int), col (int)
#S: X
#R: X
# Clase base con posición (fila, col) en el mapa.

class PersonajeBase:
    def __init__(self, fila, col):
        self.fila = fila
        self.col = col

    #E: X
    #S: tupla (fila, col)
    #R: X
    # Devuelve la posición actual del personaje.
    
    def posicion(self):
        return self.fila, self.col


#E: fila (int), col (int), modo (str)
#S: X
#R: modo debe ser "escapa" o "cazador"
# Representa al jugador (escapista o cazador).

class Jugador(PersonajeBase):
    def __init__(self, fila, col, modo):
        super().__init__(fila, col)
        self.modo = modo
        self.energia_max = 100
        self.energia = self.energia_max
        self.vivo = True
        self.trampas = []          # lista de (fila, col, timestamp)
        self.ultimo_trampa = 0.0   # tiempo del último intento de trampa

    #E: lab (Laberinto), nf (int), nc (int)
    #S: bool
    #R: nf y nc dentro del rango del laberinto
    # Indica si el jugador puede moverse a la casilla dada según su modo.
    def puede_mover(self, lab, nf, nc):
        cas = lab.casilla(nf, nc)
        if cas is None:
            return False
        # MURO: nadie
        if cas.tipo == MURO:
            return False
        # CAMINO: siempre
        if cas.tipo == CAMINO:
            return True
        # LIANA: solo cazador
        if cas.tipo == LIANA:
            return self.modo == "cazador"
        # TUNEL: solo escapista
        if cas.tipo == TUNEL:
            return self.modo == "escapa"
        return False

    #E: lab (Laberinto), df (int), dc (int), corriendo (bool)
    #S: bool
    #R: df y dc deben ser -1,0 o 1
    # Mueve al jugador una casilla si es posible, usando energía si va corriendo.
    def mover(self, lab, df, dc, corriendo):
        if not self.vivo:
            return False
        nf = self.fila + df
        nc = self.col + dc
        if not lab.dentro_rango(nf, nc):
            return False
        if not self.puede_mover(lab, nf, nc):
            return False

        self.fila = nf
        self.col = nc
        return True

    #E: X
    #S: bool
    #R: X
    # Indica si el jugador puede colocar una trampa en ese momento.
    def puede_colocar_trampa(self):
        ahora = time.time()
        if len(self.trampas) >= 3:
            return False
        if ahora - self.ultimo_trampa < 5.0:
            return False
        return True

    #E: X
    #S: bool
    #R: X
    # Coloca una trampa en la posición actual si es posible.
    def colocar_trampa(self):
        if self.puede_colocar_trampa():
            self.trampas.append((self.fila, self.col, time.time()))
            self.ultimo_trampa = time.time()
            return True
        return False

    #E: X
    #S: X
    #R: X
    # Limpia trampas viejas (no se usa tiempo de expiración en este diseño).
    def limpiar_trampas_viejas(self):
        nuevas = []
        for (f, c, t0) in self.trampas:
            nuevas.append((f, c, t0))
        self.trampas = nuevas

#E: fila (int), col (int)
#S: X
#R: X
# Representa a un enemigo (cazador o escapista según el modo).
class Enemigo(PersonajeBase):
    def __init__(self, fila, col):
        super().__init__(fila, col)
        self.vivo = True
        self.muerto_timestamp = 0.0

    #E: lab (Laberinto), nf (int), nc (int)
    #S: bool
    #R: nf y nc dentro de rango
    # Indica si el enemigo puede estar en esa casilla.
    def puede_mover(self, lab, nf, nc):
        return lab.permite_enemigo(nf, nc)

    #E: lab (Laberinto), objetivo_f (int), objetivo_c (int)
    #S: X
    #R: X
    # Mueve al enemigo aproximándose al objetivo usando distancia Manhattan.
    def mover_hacia(self, lab, objetivo_f, objetivo_c):
        if not self.vivo:
            return
        vecinos = self._vecinos_validos(lab)
        if not vecinos:
            return
        mejor = None
        mejor_dist = None
        for nf, nc in vecinos:
            dist = abs(nf - objetivo_f) + abs(nc - objetivo_c)
            if mejor is None or dist < mejor_dist:
                mejor = (nf, nc)
                mejor_dist = dist
        if mejor is not None:
            self.fila, self.col = mejor

    #E: lab (Laberinto), jugador_f (int), jugador_c (int)
    #S: X
    #R: X
    # Mueve al enemigo intentando alejarse del jugador.
    def mover_alejandose(self, lab, jugador_f, jugador_c):
        if not self.vivo:
            return
        vecinos = self._vecinos_validos(lab)
        if not vecinos:
            return
        mejor = (self.fila, self.col)
        mejor_dist = abs(self.fila - jugador_f) + abs(self.col - jugador_c)
        for nf, nc in vecinos:
            dist = abs(nf - jugador_f) + abs(nc - jugador_c)
            if dist > mejor_dist:
                mejor = (nf, nc)
                mejor_dist = dist
        self.fila, self.col = mejor

    #E: lab (Laberinto)
    #S: lista de tuplas (fila,col)
    #R: X
    # Devuelve lista de casillas vecinas válidas a las que puede moverse.

    def _vecinos_validos(self, lab):
        dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        res = []
        for df, dc in dirs:
            nf = self.fila + df
            nc = self.col + dc
            if lab.dentro_rango(nf, nc) and self.puede_mover(lab, nf, nc):
                res.append((nf, nc))
        return res

# ============================================================
#                 Lógica de juego y modos                    #
# ============================================================

#E: X
#S: diccionario con parámetros de dificultad por modo
#R: X
# Devuelve la configuracion de dificultad para Escapa y Cazador

def obtener_config_dificultad():
    return {
        "escapa": {
            "facil": {
                "num_enemigos": 2,
                "intervalo_enemigos_ms": 260,
                "pasos_sprint": 2,
                "costo_sprint": 4,
                "mult_puntaje": 1.0,
            },
            "medio": {
                "num_enemigos": 3,
                "intervalo_enemigos_ms": 200,
                "pasos_sprint": 2,
                "costo_sprint": 5,
                "mult_puntaje": 1.5,
            },
            "dificil": {
                "num_enemigos": 4,
                "intervalo_enemigos_ms": 150,
                "pasos_sprint": 1,
                "costo_sprint": 6,
                "mult_puntaje": 2.0,
            },
        },
        "cazador": {
            "facil": {
                "num_enemigos": 3,
                "intervalo_enemigos_ms": 260,
                "delay_cazador": 0.08,
                "puntaje_perdida": 8,
                "tiempo_limite": 90,
            },
            "medio": {
                "num_enemigos": 4,
                "intervalo_enemigos_ms": 220,
                "delay_cazador": 0.11,
                "puntaje_perdida": 10,
                "tiempo_limite": 90,
            },
            "dificil": {
                "num_enemigos": 5,
                "intervalo_enemigos_ms": 180,
                "delay_cazador": 0.14,
                "puntaje_perdida": 12,
                "tiempo_limite": 90,
            },
        },
    }


#E: ruta (str)
#S: lista de tuplas (nombre, puntaje)
#R: Si el archivo no exiiste, devuelve lista vacía
# Carga puntajes desde un archivo txt de top 5.

def cargar_scores_desde_txt(ruta):
    scores = []
    if not os.path.isfile(ruta):
        return scores
    with open(ruta, "r", encoding="utf-8") as f:
        for linea in f:
            linea = linea.strip()
            if not linea:
                continue
            partes = linea.split(";")
            if len(partes) < 2:
                continue
            nombre = partes[0].strip()
            try:
                puntaje = int(partes[1])
            except ValueError:
                continue
            scores.append((nombre, puntaje))
    return scores


#E: ruta (str), lista_scores (lista de tuplas)
#S: X
#R: X
# Guarda la lista de puntajes en archivo txt.

def guardar_scores_en_txt(ruta, lista_scores):
    with open(ruta, "w", encoding="utf-8") as f:
        for nombre, puntaje in lista_scores:
            f.write(f"{nombre};{puntaje}\n")


#E: modo (str), nombre (str), puntaje (int)
#S: X
#R: modo debe ser "escapa" o "cazador"
# Actualiza el top 5 de puntajes según el modo si el nuevo entra en el ranking
def actualizar_top5(modo, nombre, puntaje):
    if modo == "escapa":
        ruta = SCORES_ESCAPA_FILE
    else:
        ruta = SCORES_CAZADOR_FILE
    scores = cargar_scores_desde_txt(ruta)
    scores.append((nombre, puntaje))
    scores.sort(key=lambda x: x[1], reverse=True)
    top5 = scores[:5]
    if (nombre, puntaje) in top5:
        guardar_scores_en_txt(ruta, top5)


#E: scores (lista de tuplas), titulo (str)
#S: str
#R: X
# Da formato de texto a una lista de puntajes con titulo

def formatear_scores(scores, titulo):
    lineas = [titulo]
    if not scores:
        lineas.append("  (Sin registros)")
    else:
        pos = 1
        for nombre, puntaje in scores:
            lineas.append(f"  {pos}. {nombre} - {puntaje}")
            pos += 1
    return "\n".join(lineas)


#E: root (tk.Tk), texto (str)
#S: str o None
#R: X
# Pide el nombre del jugador en un pop up
def pedir_nombre_jugador(root, texto="Nombre del jugador:"):
    top = tk.Toplevel(root)
    top.title("Nombre del jugador")
    top.resizable(False, False)
    top.grab_set()

    sw = root.winfo_screenwidth()
    sh = root.winfo_screenheight()
    w, h = 300, 140
    x = (sw // 2) - (w // 2)
    y = (sh // 2) - (h // 2)
    top.geometry(f"{w}x{h}+{x}+{y}")

    frame = tk.Frame(top, bg="#20242d")
    frame.pack(padx=10, pady=10, fill="both", expand=True)

    lbl = tk.Label(frame, text=texto, fg="white", bg="#20242d")
    lbl.pack(pady=5)

    entrada = tk.Entry(frame, width=28)
    entrada.pack(pady=5)
    entrada.focus()

    resultado = {"nombre": None}

    def aceptar():
        nombre = entrada.get().strip()
        if not nombre:
            messagebox.showerror("Error", "Debe escribir un nombre.", parent=top)
            return
        resultado["nombre"] = nombre
        top.destroy()

    def cancelar():
        resultado["nombre"] = None
        top.destroy()

    btns = tk.Frame(frame, bg="#20242d")
    btns.pack(pady=5)
    tk.Button(btns, text="Aceptar", width=10, command=aceptar, bg="#3b82f6", fg="white", relief="flat").grid(row=0, column=0, padx=5)
    tk.Button(btns, text="Cancelar", width=10, command=cancelar, bg="#9ca3af", fg="black", relief="flat").grid(row=0, column=1, padx=5)

    top.wait_window()
    return resultado["nombre"]

#E: X
#S: X
#R: X
# Maneja toda la lógica del juego, modoss, GUI y dificultad

class Juego:
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("Escapa / Cazador - Proyecto 2")
        self.root.configure(bg="#111827")

        # modo actual
        self.modo = "escapa" 
        self.dificultad = "medio"
        self.config_dificultad = obtener_config_dificultad()

        # laberinto y personajes
        self.laberinto = Laberinto(FILAS_MAPA, COLS_MAPA)
        self.jugador = Jugador(self.laberinto.inicio[0], self.laberinto.inicio[1], self.modo)
        self.enemigos = []

        self.nombre_jugador = ""
        self.enemigos_eliminados = 0

        # estado de juego
        self.corriendo = False
        self.en_partida = False
        self.tiempo_inicio = None
        self.tiempo_limite_cazador = 90
        self.puntaje = 0
        self.ultimo_mov_cazador = 0.0

        # Layout principal
        main_frame = tk.Frame(self.root, bg="#111827")
        main_frame.pack(fill="both", expand=True, padx=10, pady=10)

        # Panel de opciones a la izquierda
        panel_izq = tk.Frame(main_frame, bg="#020617", bd=1, relief="ridge")
        panel_izq.pack(side="left", fill="y", padx=(0, 10), pady=5)

        # Frame del mapa a la derecha, el canvas se centra dentro
        frame_mapa = tk.Frame(main_frame, bg="#111827")
        frame_mapa.pack(side="right", fill="both", expand=True, padx=(10, 0), pady=5)

        self.canvas = tk.Canvas(
            frame_mapa,
            width=COLS_MAPA * TAM_CELDA,
            height=FILAS_MAPA * TAM_CELDA + 80,
            bg="#020617",
            highlightthickness=0
        )
        self.canvas.pack(expand=True)

        #Panel lateral modificado (estético v2)
        titulo = tk.Label(
                    panel_izq,
                    text="Escapa del Laberinto",
                    font=("Segoe UI", 14, "bold"),
                    bg="#020617",
                    fg="#e5e7eb"
                )
                titulo.pack(pady=(10, 4), padx=10)
        
                separador1 = tk.Frame(panel_izq, bg="#1f2937", height=2)
                separador1.pack(fill="x", padx=10, pady=(0, 8))
        
                blk_modo = tk.Frame(panel_izq, bg="#020617")
                blk_modo.pack(fill="x", padx=12, pady=4)
                tk.Label(blk_modo, text="Modo de juego", font=("Segoe UI", 10, "bold"),
                         bg="#020617", fg="#9ca3af").pack(anchor="w")
        
                self.var_modo = tk.StringVar(value="escapa")
                rb1 = tk.Radiobutton(
                    blk_modo,
                    text="Escapa",
                    variable=self.var_modo,
                    value="escapa",
                    command=self.cambiar_modo,
                    bg="#020617",
                    fg="#e5e7eb",
                    selectcolor="#1d4ed8",
                    activebackground="#020617",
                    activeforeground="#e5e7eb",
                    anchor="w",
                    justify="left"
                )
                rb2 = tk.Radiobutton(
                    blk_modo,
                    text="Cazador",
                    variable=self.var_modo,
                    value="cazador",
                    command=self.cambiar_modo,
                    bg="#020617",
                    fg="#e5e7eb",
                    selectcolor="#1d4ed8",
                    activebackground="#020617",
                    activeforeground="#e5e7eb",
                    anchor="w",
                    justify="left"
                )
                rb1.pack(anchor="w")
                rb2.pack(anchor="w")
        
                blk_dif = tk.Frame(panel_izq, bg="#020617")
                blk_dif.pack(fill="x", padx=12, pady=(4, 6))
                tk.Label(blk_dif, text="Dificultad", font=("Segoe UI", 10, "bold"),
                         bg="#020617", fg="#9ca3af").pack(anchor="w")
        
                self.var_dif = tk.StringVar(value="medio")
                tk.Radiobutton(
                    blk_dif, text="Fácil",
                    variable=self.var_dif, value="facil",
                    command=self.cambiar_dificultad,
                    bg="#020617", fg="#e5e7eb",
                    selectcolor="#15803d",
                    activebackground="#020617",
                    activeforeground="#e5e7eb",
                    anchor="w"
                ).pack(anchor="w")
                tk.Radiobutton(
                    blk_dif, text="Medio",
                    variable=self.var_dif, value="medio",
                    command=self.cambiar_dificultad,
                    bg="#020617", fg="#e5e7eb",
                    selectcolor="#ea580c",
                    activebackground="#020617",
                    activeforeground="#e5e7eb",
                    anchor="w"
                ).pack(anchor="w")
                tk.Radiobutton(
                    blk_dif, text="Difícil",
                    variable=self.var_dif, value="dificil",
                    command=self.cambiar_dificultad,
                    bg="#020617", fg="#e5e7eb",
                    selectcolor="#b91c1c",
                    activebackground="#020617",
                    activeforeground="#e5e7eb",
                    anchor="w"
                ).pack(anchor="w")
        
                separador2 = tk.Frame(panel_izq, bg="#1f2937", height=2)
                separador2.pack(fill="x", padx=10, pady=(4, 8))
        
                def btn_estetico(texto, comando, color="#2563eb"):
                    return tk.Button(
                        panel_izq,
                        text=texto,
                        command=comando,
                        bg=color,
                        fg="white",
                        relief="flat",
                        activebackground="#1d4ed8",
                        activeforeground="white",
                        font=("Segoe UI", 9, "bold"),
                        padx=8,
                        pady=4
                    )
        
                btn_estetico("Nueva partida", self.nueva_partida, "#16a34a").pack(fill="x", padx=12, pady=(2, 4))
                btn_estetico("Detener partida", self.detener_partida, "#b91c1c").pack(fill="x", padx=12, pady=2)
                btn_estetico("Ver Top 5 puntajes", self.mostrar_top_scores, "#2563eb").pack(fill="x", padx=12, pady=(2, 8))
        
                separador3 = tk.Frame(panel_izq, bg="#1f2937", height=2)
                separador3.pack(fill="x", padx=10, pady=(4, 8))
        
                self.lbl_estado = tk.Label(panel_izq, text="Estado: listo", justify="left",
                                           bg="#020617", fg="#e5e7eb", font=("Segoe UI", 9))
                self.lbl_estado.pack(pady=2, anchor="w", padx=12)
        
                self.lbl_jugador = tk.Label(panel_izq, text="Jugador: -", justify="left",
                                            bg="#020617", fg="#e5e7eb", font=("Segoe UI", 9))
                self.lbl_jugador.pack(pady=2, anchor="w", padx=12)
        
                self.lbl_puntaje = tk.Label(panel_izq, text="Puntaje: 0", justify="left",
                                            bg="#020617", fg="#e5e7eb", font=("Segoe UI", 9))
                self.lbl_puntaje.pack(pady=2, anchor="w", padx=12)
        
                self.lbl_tiempo = tk.Label(panel_izq, text="Tiempo: 0.0 s", justify="left",
                                           bg="#020617", fg="#e5e7eb", font=("Segoe UI", 9))
                self.lbl_tiempo.pack(pady=2, anchor="w", padx=12)
        
                self.lbl_energia = tk.Label(panel_izq, text="Energía: 100 / 100", justify="left",
                                            bg="#020617", fg="#e5e7eb", font=("Segoe UI", 9))
                self.lbl_energia.pack(pady=2, anchor="w", padx=12)
        
                hint = (
                    "Controles:\n"
                    "  Flechas: Mover\n"
                    "  Shift: Correr (Consume energía)\n"
                    "  Espacio: Trampa (Modo Escapa)\n"
                )
                tk.Label(panel_izq, text=hint, justify="left",
                         bg="#020617", fg="#9ca3af", font=("Segoe UI", 8)).pack(pady=10, anchor="w", padx=12)
        
                # eventos
                self.root.bind("<KeyPress>", self.on_key_press)
                self.root.bind("<KeyRelease-Shift_L>", self.on_key_release_shift)
                self.root.bind("<KeyRelease-Shift_R>", self.on_key_release_shift)
        
                # bucles periódicos
                self.actualizar_dibujo()
                self.loop_enemigos()
        
                # enemigos iniciales (después de crear var_dif)
                self.crear_enemigos_iniciales()

    # popups 
    #E: titulo (str), texto (str)
    #S: X
    #R: X
    # Muestra un popup con iinfo

    def popup_info(self, titulo, texto):
        top = tk.Toplevel(self.root)
        top.title(titulo)
        top.resizable(False, False)
        top.grab_set()

        w, h = 420, 260
        sw = self.root.winfo_screenwidth()
        sh = self.root.winfo_screenheight()
        x = (sw // 2) - (w // 2)
        y = (sh // 2) - (h // 2)
        top.geometry(f"{w}x{h}+{x}+{y}")

        frame = tk.Frame(top, bg="#020617")
        frame.pack(fill="both", expand=True, padx=12, pady=12)

        lbl = tk.Label(
            frame,
            text=texto,
            bg="#020617",
            fg="#e5e7eb",
            justify="left",
            wraplength=380
        )
        lbl.pack(pady=(4, 12))

        btn = tk.Button(
            frame,
            text="Aceptar",
            command=top.destroy,
            bg="#2563eb",
            fg="white",
            relief="flat",
            padx=12,
            pady=4
        )
        btn.pack(pady=(0, 6))

        top.wait_window()

    #E: titulo (str), texto (str)
    #S: X
    #R: X
    # Muestra un popup de error

    def popup_error(self, titulo, texto):
        top = tk.Toplevel(self.root)
        top.title(titulo)
        top.resizable(False, False)
        top.grab_set()

        w, h = 420, 220
        sw = self.root.winfo_screenwidth()
        sh = self.root.winfo_screenheight()
        x = (sw // 2) - (w // 2)
        y = (sh // 2) - (h // 2)
        top.geometry(f"{w}x{h}+{x}+{y}")

        frame = tk.Frame(top, bg="#111827")
        frame.pack(fill="both", expand=True, padx=12, pady=12)

        lbl_t = tk.Label(
            frame,
            text=titulo,
            bg="#111827",
            fg="#f87171",
            font=("Segoe UI", 11, "bold")
        )
        lbl_t.pack(pady=(0, 6))

        lbl = tk.Label(
            frame,
            text=texto,
            bg="#111827",
            fg="#e5e7eb",
            justify="left",
            wraplength=380
        )
        lbl.pack(pady=(0, 12))

        btn = tk.Button(
            frame,
            text="Cerrar",
            command=top.destroy,
            bg="#b91c1c",
            fg="white",
            relief="flat",
            padx=12,
            pady=4
        )
        btn.pack(pady=(0, 4))

        top.wait_window

    ###

    #E: X
    #S: dicc
    #R: X
    # Obtiene la configuración actual de dificultad para el modo activo.
    def get_params_dificultad_actual(self):
        self.dificultad = self.var_dif.get()
        return self.config_dificultad[self.modo][self.dificultad]

    #E: X
    #S: int milisegundos
    #R: X
    # Devuelve el intervalo de movimiento de enemigos según modo y dificultad.
    def get_intervalo_enemigos_ms(self):
        params = self.get_params_dificultad_actual()
        return params["intervalo_enemigos_ms"]

    #E: X
    #S: int pasos
    #R: X
    # Devuelve cuántas casillas avanza el escapista por pulsación al correr.
    def get_pasos_sprint_escapa(self):
        if self.modo != "escapa":
            return 1
        params = self.get_params_dificultad_actual()
        return params["pasos_sprint"]

    #E: X
    #S: int
    #R: X
    # Devuelve cuánto cuesta en energía cada paso de sprint.
    def get_costo_sprint(self):
        params = self.get_params_dificultad_actual()
        if self.modo == "escapa":
            return params["costo_sprint"]
        else:
            return 4

    #E: X
    #S: float
    #R: X
    # Devuelve el multiplicador de puntaje de Escapa según dificultad.
    def get_mult_puntaje_escapa(self):
        params = self.config_dificultad["escapa"][self.var_dif.get()]
        return params["mult_puntaje"]

    #E: X
    #S: float segundos
    #R: X
    # Devuelve el retraso mínimo entre movimientos del cazador.
    def get_delay_cazador(self):
        params = self.config_dificultad["cazador"][self.var_dif.get()]
        return params["delay_cazador"]

    #E: X
    #S: (ganancia, perdida)
    #R: X
    # Devuelve puntajes de ganar/perder por enemigo en modo cazador (ganancia = 2 * perdida).
    def get_puntajes_cazador(self):
        params = self.config_dificultad["cazador"][self.var_dif.get()]
        perdida = params["puntaje_perdida"]
        ganancia = perdida * 2
        return ganancia, perdida

    #E: X
    #S: int segundos
    #R: X
    # Devuelve el tiempo límite del modo cazador según dificultad.
    def get_time_limit_cazador(self):
        params = self.config_dificultad["cazador"][self.var_dif.get()]
        return params["tiempo_limite"]

    #E: X
    #S: X
    #R: X
    # Crea enemigos en posiciones válidas según modo y dificultad.
    def crear_enemigos_iniciales(self):
        self.enemigos.clear()
        params = self.get_params_dificultad_actual()
        num = params["num_enemigos"]
        for _ in range(num):
            while True:
                f = random.randint(0, self.laberinto.filas - 1)
                c = random.randint(0, self.laberinto.cols - 1)
                if not self.laberinto.permite_enemigo(f, c):
                    continue
                if (f, c) == self.laberinto.inicio:
                    continue
                self.enemigos.append(Enemigo(f, c))
                break

    #E: X
    #S: X
    #R: X
    # Cambia el modo de juego (si no hay partida en curso).
    def cambiar_modo(self):
        if self.en_partida:
            return
        self.modo = self.var_modo.get()
        self.jugador.modo = self.modo
        self.lbl_estado.config(text=f"Estado: Modo {self.modo}")
        self.crear_enemigos_iniciales()

    #E: X
    #S: X
    #R: X
    # Cambia la dificultad (si no hay partida en curso).
    def cambiar_dificultad(self):
        if self.en_partida:
            return
        self.dificultad = self.var_dif.get()
        self.crear_enemigos_iniciales()

    #E: X
    #S: X
    #R: X
    # Crea una nueva partida: pide nombre, reinicia mapa, jugador y enemigos.
    def nueva_partida(self):
        nombre = pedir_nombre_jugador(self.root, "Ingrese su nombre para esta partida:")
        if not nombre:
            return
        self.nombre_jugador = nombre
        self.lbl_jugador.config(text=f"Jugador: {self.nombre_jugador}")

        self.laberinto.generar_mapa()
        self.jugador = Jugador(self.laberinto.inicio[0], self.laberinto.inicio[1], self.modo)
        self.enemigos_eliminados = 0
        self.crear_enemigos_iniciales()
        self.en_partida = True
        self.tiempo_inicio = time.time()

        if self.modo == "cazador":
            self.tiempo_limite_cazador = self.get_time_limit_cazador()
        self.puntaje = 0
        self.ultimo_mov_cazador = 0.0
        self.lbl_estado.config(text="Estado: partida en curso")
        self.lbl_puntaje.config(text="Puntaje: 0")

    #E: X
    #S: X
    #R: X
    # Detiene la partida actual, permitiendo cambiar modo/dificultad.
    def detener_partida(self):
        if self.en_partida:
            self.en_partida = False
            self.lbl_estado.config(text="Estado: partida detenida")

    #E: X
    #S: X
    #R: X
    # Muestra un popup con el Top 5 de ambos modos (escapa y cazador).

    def mostrar_top_scores(self):
        scores_esc = cargar_scores_desde_txt(SCORES_ESCAPA_FILE)
        scores_caz = cargar_scores_desde_txt(SCORES_CAZADOR_FILE)
        texto = formatear_scores(scores_esc, "Top 5 - Modo Escapa") + "\n\n" + \
                formatear_scores(scores_caz, "Top 5 - Modo Cazador")
        self.popup_info("Mejores puntajes", texto)


    #E: evento
    #S: X
    #R: X
    # Maneja las teclas presionadas para mover y colocar las trampass

    def on_key_press(self, event):
        if not self.en_partida:
            return
        key = event.keysym

        if key in ("Shift_L", "Shift_R"):
            self.corriendo = True
            return

        df, dc = 0, 0
        if key == "Up":
            df, dc = -1, 0
        elif key == "Down":
            df, dc = 1, 0
        elif key == "Left":
            df, dc = 0, -1
        elif key == "Right":
            df, dc = 0, 1
        elif key == "space":
            if self.modo == "escapa":
                ok = self.jugador.colocar_trampa()
                if ok:
                    self.lbl_estado.config(text="Estado: trampa colocada")
                    reproducir_sonido("trampa_colocada")
                else:
                    self.lbl_estado.config(
                        text="Estado: no se puede colocar trampa (máx 3 o cooldown)"
                    )
            return
        else:
            return
        # Modo cazador, controla frecuencia dell movimiento para que vaya más lento
        if self.modo == "cazador":
            ahora = time.time()
            if ahora - self.ultimo_mov_cazador < self.get_delay_cazador():
                return
            self.ultimo_mov_cazador = ahora

        # Movimiento básico
        movido = self.jugador.mover(self.laberinto, df, dc, self.corriendo)
        if movido:
            # Consumo de energía y correr
            if self.corriendo and self.jugador.energia > 0:
                costo = self.get_costo_sprint()

                if self.modo == "escapa":
                    # Sprint con pasos extra según dificultad
                    self.jugador.energia = max(0, self.jugador.energia - costo)
                    pasos_extra = max(0, self.get_pasos_sprint_escapa() - 1)
                    for _ in range(pasos_extra):
                        if self.jugador.energia <= 0:
                            break
                        segundo = self.jugador.mover(self.laberinto, df, dc, True)
                        if not segundo:
                            break
                        self.jugador.energia = max(0, self.jugador.energia - costo)
                else:
                    # Modo cazador. Correr consume energía
                    self.jugador.energia = max(0, self.jugador.energia - costo)

            # Si el cazador pasa encima de un enemigo, lo elimina
            if self.modo == "cazador":
                jf, jc = self.jugador.posicion()
                for e in self.enemigos:
                    if e.vivo and e.posicion() == (jf, jc):
                        ganancia, _ = self.get_puntajes_cazador()
                        self.puntaje += ganancia
                        self.lbl_puntaje.config(text=f"Puntaje: {self.puntaje}")
                        reproducir_sonido("cazador_atrapa")
                        
                        #respawn en 5 segundos
                        e.vivo = False
                        e.muerto_timestamp = time.time()

            self.verificar_eventos_post_movimiento()

    #E: evento
    #S: X
    #R: X
    # Desactiva el sprint cuando no se presiona shift

    def on_key_release_shift(self, event):
        self.corriendo = False

#Configuración lógica del juego.

    #E: X
    #S: X
    #R: X
    # Revisa eventos luego de que el jugador se mueve (ej. llegar a la salida).
    def verificar_eventos_post_movimiento(self):
        if (self.jugador.fila, self.jugador.col) == self.laberinto.salida:
            if self.modo == "escapa":
                self.ganar_escapa()

    #E: X
    #S: X
    #R: X
    # Lógica de victoria en modo Escapa, calcula puntaje, guarda y muestra pop up bonito.
    def ganar_escapa(self):
        if not self.en_partida:
            return
        self.en_partida = False
        dur = time.time() - self.tiempo_inicio if self.tiempo_inicio else 0
        base = max(0, int(1000 - 10 * dur))
        bono_trampas = len(self.jugador.trampas) * 5
        bono_enemigos = self.enemigos_eliminados * 5
        mult = self.get_mult_puntaje_escapa()
        self.puntaje = int((base + bono_trampas + bono_enemigos) * mult)
        self.lbl_estado.config(text=f"Ganaste (Escapa). Tiempo: {dur:.1f}s")
        self.lbl_puntaje.config(text=f"Puntaje: {self.puntaje}")

        reproducir_sonido("escapa_gana")
        texto = (
            f"¡Has escapado!\n\n"
            f"Jugador: {self.nombre_jugador}\n"
            f"Tiempo: {dur:.1f} s\n"
            f"Puntaje: {self.puntaje}"
        )
        self.popup_info("Victoria - Escapa", texto)

        if self.nombre_jugador:
            actualizar_top5("escapa", self.nombre_jugador, self.puntaje)

    #E: motivo (str)
    #S: X
    #R: X
    # Termina la partida y muestra pop up de derrota con puntaje y tiempo.
    def perder(self, motivo):
        if not self.en_partida:
            return
        self.en_partida = False
        dur = time.time() - self.tiempo_inicio if self.tiempo_inicio else 0
        self.lbl_estado.config(text=f"Perdiste: {motivo}")
        reproducir_sonido("escapa_pierde")
        texto = (
            f"Has perdido.\n\n"
            f"Causa: {motivo}\n"
            f"Jugador: {self.nombre_jugador}\n"
            f"Tiempo: {dur:.1f} s\n"
            f"Puntaje: {self.puntaje}"
        )
        self.popup_info("Derrota", texto)

        if self.modo == "escapa" and self.nombre_jugador:
            actualizar_top5("escapa", self.nombre_jugador, self.puntaje)

    #E: atrapado (bool), enemigo_salio (bool)
    #S: X
    #R: Modo debe ser "cazador"
    # Actualiza puntaje en modo cazador dependiendo de atrapar o perder enemigos.
    def actualizar_puntaje_cazador(self, atrapado=False, enemigo_salio=False):
        ganancia, perdida = self.get_puntajes_cazador()
        if atrapado:
            self.puntaje += ganancia
            reproducir_sonido("cazador_atrapa")
        if enemigo_salio:
            self.puntaje -= perdida
            if self.puntaje < 0:
                self.puntaje = 0
            reproducir_sonido("enemigo_escapa")
        self.lbl_puntaje.config(text=f"Puntaje: {self.puntaje}")

    #E: X
    #S: X
    #R: X
    # Finaliza el modo cazador al agotarse el tiempo límite y muestra pop up.
    def finalizar_tiempo_cazador(self):
        if not self.en_partida or self.modo != "cazador":
            return
        self.en_partida = False
        dur = time.time() - self.tiempo_inicio if self.tiempo_inicio else 0
        self.lbl_estado.config(text="Fin del tiempo (modo Cazador)")
        texto = (
            f"Tiempo límite alcanzado.\n\n"
            f"Jugador: {self.nombre_jugador}\n"
            f"Tiempo: {dur:.1f} s\n"
            f"Puntaje final: {self.puntaje}"
        )
        self.popup_info("Tiempo agotado - Cazador", texto)

        if self.nombre_jugador:
            actualizar_top5("cazador", self.nombre_jugador, self.puntaje)
